#version 450 core

#define PI 3.1415926535

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Agent
{
    vec2 position;
    float angle;
    int species_index;
    vec4 species_mask;
};

layout (std430, binding = 0) buffer agent_buffer {
    Agent agents[];
};

layout(rgba32f, binding = 0) uniform image2D trail_image;
layout(rgba32f, binding = 1) uniform image2D diffused_trail_image;
layout(rgba32f, binding = 2) uniform image2D agent_image;
layout(r32ui, binding = 3) uniform uimage2D occupied_image;

uniform layout(location = 0) ivec2 bounds;
uniform layout(location = 1) float dt;
uniform layout(location = 2) float time;
uniform layout(location = 3) int num_agents;

uniform layout(location = 4) float move_speed;
uniform layout(location = 5) float turn_speed;
uniform layout(location = 6) float trail_weight;
uniform layout(location = 7) float sense_spacing;
uniform layout(location = 8) int sense_distance;
uniform layout(location = 9) int sense_size;

float mid(float lower, float value, float upper)
{
    return max(lower, min(value, upper));
}

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scale_to_unit(uint value)
{
    return value / 4294967295.0;
}

bool try_move(uint id, ivec2 position, ivec2 previous_position)
{
    // Check if target position is vacant
    uint prev_id = imageAtomicCompSwap(occupied_image, position, 0, id + 1);
    if (prev_id == 0)
    {
        // Mark previous position as vacant
        imageStore(occupied_image, previous_position, ivec4(0));
        return true;
    }

    return false;
}

void main()
{
	ivec2 pixel_position = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_position.x >= bounds.x || pixel_position.y >= bounds.y)
    {
        return;
    }

    uint occupied = imageLoad(occupied_image,
            ivec2(pixel_position.x, pixel_position.y)).x;
    if (occupied == 0)
    {
        return;
    }

	uint agent_id = occupied - 1;

    Agent agent = agents[agent_id];

    uint rand = hash(uint(
                agent.position.x +
                agent.position.y * bounds.x +
                time * 10000.0));

    vec2 new_position = agent.position;
    float new_angle = agent.angle;

    float random_angle = scale_to_unit(rand) * 2.0 * PI;

    vec2 velocity = vec2(cos(agent.angle), sin(agent.angle)) * move_speed;
    new_position += velocity * dt;

    if (new_position.x <= 0.0 || new_position.x > bounds.x - 1.0 ||
            new_position.y <= 0.0 || new_position.y > bounds.y - 1.0)
    {
        new_position.x = mid(0.0, new_position.x, bounds.x - 1.0);
        new_position.y = mid(0.0, new_position.y, bounds.y - 1.0);

        new_angle = random_angle;
    }

    ivec2 new_pixel_position = ivec2(new_position);
    if (pixel_position != new_pixel_position)
    {
        bool did_move = try_move(agent_id, new_pixel_position,
                pixel_position);
        if (did_move)
        {
            vec4 prev_trail =
                imageLoad(trail_image, pixel_position);
            vec4 new_trail = min(vec4(1.0),
                    prev_trail + agent.species_mask * trail_weight * dt);

            imageStore(trail_image, new_pixel_position, new_trail);

            agents[agent_id].position = new_position;
        }
        else
        {
            new_angle = random_angle;
        }
    }
    else
    {
        agents[agent_id].position = new_position;
    }

    agents[agent_id].angle = new_angle;
}
